package hash

import (
	"encoding/binary"
	"encoding/hex"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"syscall"
)

/*
 * zip2john processes input ZIP files into a format suitable for use with JtR.
 *
 * This software is Copyright (c) 2011, Dhiru Kholia <dhiru.kholia at gmail.com>,
 * and it is hereby released to the general public under the following terms:
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted.
 *
 * Updated in Aug 2011 by JimF.  Added PKZIP 'old' encryption.  The signature on the
 * pkzip will be $pkzip$ and does not look like the AES version written by Dhiru
 * Also fixed some porting issues, such as variables needing declared at top of blocks.
 *
 * Updated in 2020 by Simon Rettberg. Handle archives by scanning their central
 * directory first, which is more robust with archives that have been created using
 * streams. The old behavior of scanning for local headers from the start of the
 * file is still available through the -s option. Also fixed some minor issues and
 * refactored the code for slightly less redundant code beween AES and legacy.
 *
 * References:
 *
 * 1. http://www.winzip.com/aes_info.htm
 * 2. http://www.winzip.com/aes_tips.htm
 * 4. ftp://ftp.info-zip.org/pub/infozip/doc/appnote-iz-latest.zip
 * 5. Nathan Moinvaziri's work in extending minizip to support AES.
 * 6. http://oldhome.schmorp.de/marc/fcrackzip.html (coding hints)
 * 7. http://www.pkware.com/documents/casestudies/APPNOTE.TXT
 * 8. http://gladman.plushost.co.uk/oldsite/cryptography_technology/fileencrypt/index.php
 *   (borrowed files have "gladman_" prepended to them). This gladman code has been removed from JtR source tree.
 *
 * Usage:
 *
 * 1. Run zip2john on zip file(s) as "zip2john [zip files]".
 *    Output is written to standard output.
 * 2. Run JtR on the output generated by zip2john as "john [output file]".
 *
 * Output Line Format:
 *
 * For type = 0, for ZIP files encrypted using AES
 * filename:$zip$*type*hex(CRC)*encryption_strength*hex(salt)*hex(password_verfication_value):hex(authentication_code)
 *
 * For original pkzip encryption:  (JimF, with longer explaination of fields)
 * filename:$pkzip$C*B*[DT*MT{CL*UL*CR*OF*OX}*CT*DL*CS*DA]*$/pkzip$   (deprecated)
 * filename:$pkzip2$C*B*[DT*MT{CL*UL*CR*OF*OX}*CT*DL*CS*TC*DA]*$/pkzip2$   (new format, with 2 checksums)
 * All numeric and 'binary data' fields are stored in hex.
 *
 * C   is the count of hashes present (the array of items, inside the []  C can be 1 to 8.).
 * B   is number of valid bytes in the checksum (1 or 2).  Unix zip is 2 bytes, all others are 1 (NOTE, some can be 0)
 * ARRAY of data starts here
 *   DT  is a "Data Type enum".  This will be 1 2 or 3.  1 is 'partial'. 2 and 3 are full file data (2 is inline, 3 is load from file).
 *   MT  Magic Type enum.  0 is no 'type'.  255 is 'text'. Other types (like MS Doc, GIF, etc), see source.
 *     NOTE, CL, DL, CRC, OFF are only present if DT != 1
 *     CL  Compressed length of file blob data (includes 12 byte IV).
 *     UL  Uncompressed length of the file.
 *     CR  CRC32 of the 'final' file.
 *     OF  Offset to the PK\x3\x4 record for this file data. If DT == 2, then this will be a 0, as it is not needed, all of the data is already included in the line.
 *     OX  Additional offset (past OF), to get to the zip data within the file.
 *     END OF 'optional' fields.
 *   CT  Compression type  (0 or 8)  0 is stored, 8 is imploded.
 *   DL  Length of the DA data.
 *   CS  2 bytes of checksum data.
 *   TC  2 bytes of checksum data (from timestamp)
 *   DA  This is the 'data'.  It will be hex data if DT == 1 or 2. If DT == 3, then it is a filename (name of the .zip file).
 * END of array item.  There will be C (count) array items.
 * The format string will end with $/pkzip$
 *
 * The AES-zip format redone by JimF, Summer 2014.  Spent some time to understand the AES authentication code,
 * and now have placed code to do this. However, this required format change.  The old AES format was:
 *
 *    For type = 0, for ZIP files encrypted using AES
 *    filename:$zip$*type*hex(CRC)*encryption_strength*hex(salt)*hex(password_verfication_value):hex(authentication_code)
 *     NOTE, the authentication code was NOT part of this, even though documented in this file. nor is hex(CRC) a part.
 *
 * The new format is:  (and the $zip$ is deprecated)
 *
 *    filename:$zip2$*Ty*Mo*Ma*Sa*Va*Le*DF*Au*$/zip2$
 *    Ty = type (0) and ignored.
 *    Mo = mode (1 2 3 for 128/192/256 bit)
 *    Ma = magic (file magic).  This is reservered for now.  See pkzip_fmt_plug.c or zip2john.c for information.
 *         For now, this must be a '0'
 *    Sa = salt(hex).   8, 12 or 16 bytes of salt (depends on mode)
 *    Va = Verification bytes(hex) (2 byte quick checker)
 *    Le = real compr len (hex) length of compressed/encrypted data (field DF)
 *    DF = compressed data DF can be Le*2 hex bytes, and if so, then it is the ENTIRE file blob written 'inline'.
 *         However, if the data blob is too long, then a .zip ZIPDATA_FILE_PTR_RECORD structure will be the 'contents' of DF
 *    Au = Authentication code (hex) a 10 byte hex value that is the hmac-sha1 of data over DF. This is the binary() value
 *
 *  ZIPDATA_FILE_PTR_RECORD  (this can be the 'DF' of this above hash line).
 *      *ZFILE*Fn*Oh*Ob*  (Note, the leading and trailing * are the * that 'wrap' the DF object.
 *  ZFILE This is the literal string ZFILE
 *  Fn    This is the name of the .zip file.  NOTE the user will need to keep the .zip file in proper locations (same as
 *        was seen when running zip2john. If the file is removed, this hash line will no longer be valid.
 *  Oh    Offset to the zip local header record for this blob.
 *  Ob    Offset to the start of the blob data
 *
 *
 * The new format for PKWARE's Strong Encryption Specification is:
 *
 *    filename:$zip3$*Ty*Al*Bi*Ma*Sa*Erd*Le*DF*Au*Fn
 *    Ty = type (0) and ignored.
 *    Al = algorithm (1 for AES)
 *    Bi = bit length (128/192/256 bit)
 *    Ma = magic (file magic), reserved, must be '0' now
 *    Sa = salt(hex), 12 or 16 bytes of IV data
 *    Erd = encrypted random data (max. 256 bytes)
 *    Le = real compr len (hex) length of compressed/encrypted data (field DF), unused currently
 *    DF = compressed data DF can be Le*2 hex bytes, and if so, then it is the ENTIRE file blob written 'inline', unused currently
 *    Au = authentication code, a 8 byte hex value that contains a CRC32 checksum, unused currently
 *    Fn = filename within zip file
 */




//var  _STR_VALUE(arg) #arg
//var  STR_MACRO(n)    _STR_VALUE(n)
//var MAX_FILES STR_MACRO(MAX_PKZ_FILES)

var MAX_BLOB_INLINE_SIZE uint64= 0x400000000 // 16 GB
var  MAX_PKZ_FILES= 8

var FLAG_ENCRYPTED    uint16 =       1
var FLAG_LOCAL_SIZE_UNKNOWN uint16 =  8
var FLAG_STRONG_ENCRYPTION uint16=  64

var AES_EXTRA_DATA_LENGTH= 7  // https://www.winzip.com/aes_info.html#extra-data
var AES_AUTHENTICATION_CODE_LENGTH uint64=10 // http://www.winzip.com/aes_info.htm#authentication-code
var AES_PASSWORD_VERIFICATION_LENGTH uint64= 2 // https://www.winzip.com/aes_info.html#pwd-verify

// TODO: Add macro for fprintf(stderr, ...) and make DEBUG a command line switch



func xfread( stream *os.File,_len int) (int,string) {
	var cp=make([]byte,_len)
	_,err:=stream.Read(cp)
	if (err!=nil) {
		return 0,"";
	}
	return _len,string(cp);
}


/**
 * Read a char from stream, push it back if it doesn't have the expected value.
 * This is so we can properly look for header magic (32bit).
 */
func fexpect(stream *os.File,  c byte) int {
	d:=fgetc(stream)
	if d != c {
		stream.Seek(-1,syscall.FILE_CURRENT);
	}
	if d == c {
		return 1;
	}
	return 0;
}

var   checksum_only int;
var use_magic int;
var  ascii_fname string;
var only_fname string;

var MagicTypes =  []string{ "", "DOC", "XLS", "DOT", "XLT", "EXE", "DLL", "ZIP", "BMP", "DIB", "GIF", "PDF", "GZ", "TGZ", "BZ2", "TZ2", "FLV", "SWF", "MP3", "PST", "0" };
var   MagicToEnum = []byte{  0,   1,     1,     1,     1,     2,     2,     3,     4,     4,     5,     6,     7,    7,     8,     8,     9,     10,    11,  12, 0 };
/*
func print_hex_inline(unsigned char *str, int len){
	int i;
	for (i = 0; i < len; ++i)
		printf("%02x", str[i]);
}*/

var UINT64_MAX     uint64 = 18446744073709551615
var UINT32_MAX   =     4294967295

type Aes struct {
	vendor_version uint16
	vendor_id uint16
	cmptype uint16;
	strength byte;
	found int ;
}

// Represents a file in the archive
type zip_ptr struct {
	version uint16
	flags uint16
	magic_type uint16
	cmptype uint16
	hash_data []byte
	file_name string
	offset uint64
	offex uint64;
	cmp_len uint64
	decomp_len uint64;
	crc uint32;
	chksum string;
	chksum2 string;
	zip64 int; // Has extended header with 64bit data
	lastmod_date uint16
	lastmod_time uint16;
	extrafield_length uint16;
	aes Aes
}





// Represents a zip archive
type zip_file struct {
	fp *os.File;
	fname string;
	check_bytes int;  // number of valid bytes in checksum
	zip64 int; // Is ZIP64 format (has ZIP64 EOCD)
}

// Wrapper struct so we don't have to pass three pointers all the time
type zip_context struct {
	best_files []zip_ptr; // Up to 8 candidates for handling old encryption type archives
	curzip zip_ptr;         // Meta data of file in archive we're currently processing
	archive zip_file;       // The zip file being processed
	num_candidates int;     // Number of candidates in best_files array
}

func fget64LE(fp *os.File)uint64{
	var Buf=make([]byte,8);
	var n uint64= 0;
	_,err:=fp.Read(Buf)
	if err!=nil {
		return 0;
	}
	n=binary.LittleEndian.Uint64(Buf)
	return n;
}
func fget16LE(fp *os.File)uint16{
	var Buf=make([]byte,2);
	var n uint16= 0;
	_,err:=fp.Read(Buf)
	if err!=nil {
		return 0;
	}
	n=binary.LittleEndian.Uint16(Buf)
	return n;
}
func fgetc(fp *os.File)byte{
	var Buf=make([]byte,1);
	_,err:=fp.Read(Buf)
	if err!=nil {
		return 0;
	}
	return Buf[0]
}

func fget32LE(fp *os.File)uint32{
	var Buf=make([]byte,4);
	var n uint32= 0;
	_,err:=fp.Read(Buf)
	if err!=nil {
		return 0;
	}
	n=binary.LittleEndian.Uint32(Buf)
	return n;
}


/**
 * Read 64bit fields from zip64 extended file header.
 * fp is expected to point right after the tag and size of the efh
 */
func  handle_zip64_ef(fp *os.File,  p *zip_ptr,  _len uint16,  is_local int) {
	var decomp_len uint64= UINT64_MAX
	var cmp_len uint64= UINT64_MAX
	var offset uint64= UINT64_MAX;
	var rem_len = _len;

	// Only read this if we didn't get it from the Central Directory yet, otherwise
	// we need to store both, local and central values in the zip_ptr struct, as the
	// handle_zip64_ef function needs to know whether the fields of the header this
	// extra field belongs to were 0xff..ff, because only in that case the according
	// 64bit fields will be present here.
	// See "4.5.3 -Zip64 Extended Information Extra Field (0x0001)" in APPNOTE.TXT
	// The additional checks that reset the read values to UINT64_MAX (=not present)
	// is a workaround for archives that have valid values in their normal headers
	// (ie. fitting into 32bit) but additionally supply a bogus ZIP64 extended field
	// in their local header, where the according fields are 0.
	if p.zip64>0 {
		fp.Seek(int64(_len),syscall.FILE_CURRENT)
		return;
	}
	if (p.decomp_len ==uint64( UINT32_MAX) || is_local>0) {
		decomp_len= fget64LE(fp)
		if (p.decomp_len != uint64(UINT32_MAX) && decomp_len == 0) {
			decomp_len = UINT64_MAX;
		}
		rem_len -= 8;
	}
	if (p.cmp_len == uint64(UINT32_MAX) || is_local>0) {
		cmp_len = fget64LE(fp);
		if (p.cmp_len != uint64(UINT32_MAX) && cmp_len == 0) {
			cmp_len = UINT64_MAX;
		}
		rem_len -= 8;
	}
	if (p.offset == uint64(UINT32_MAX)) {
		offset = fget64LE(fp);
		if (p.offset != uint64(UINT32_MAX) && offset == 0) {
			offset = UINT64_MAX;
		}
		rem_len -= 8;
	}
	// Other fields we don't care about follow...
	// Now only apply what we read if there was enough bytes in the field
	if rem_len >= 0 {
		p.zip64 = 1;
		if (decomp_len != UINT64_MAX) {
			p.decomp_len = decomp_len;
		}
		if (cmp_len != UINT64_MAX) {
			p.cmp_len = cmp_len;
		}
		if (offset != UINT64_MAX) {
			p.offset = offset;
		}
	} else {
		fmt.Fprintf(os.Stderr, "Ignoring short zip64 extended field for %s\n", p.file_name);
	}
	fp.Seek(int64(rem_len),syscall.FILE_CURRENT)

}

/**
 * Handle the extended field for AES encrypted files (99)
 */
func handle_aes_ef( fp *os.File,  p *zip_ptr,  _len uint16) {
	// Data size: this value is currently 7, but because it is possible that this
	// specification will be modified in the future to store additional data in
	// this extra field, vendors should not assume that it will always remain 7.
	if _len != uint16(AES_EXTRA_DATA_LENGTH) {
		fmt.Fprintf(os.Stderr, "AES_EXTRA_DATA_LENGTH is not 7 for %s, please report this to us!\n", p.file_name);
		fp.Seek(int64(_len),syscall.FILE_CURRENT)
		return;
	}
	p.aes.found = 1;
	p.aes.vendor_version = fget16LE(fp);
	p.aes.vendor_id = fget16LE(fp);
	p.aes.strength = fgetc(fp);
	p.aes.cmptype = fget16LE(fp);
}

//var  void scan_for_data_descriptor(zip_file *zip, zip_ptr *p);

/**
 * Process AES encrypted file in zip and produce according hash.
 * file pointer in archive is assumed to be at the beginning of
 * the local extra fields.
 */
func  process_aes( zip *zip_file,  p *zip_ptr) int {
	var fp = zip.fp;

	if (p.cmptype == 99) {	/* AES encryption */
		var  real_cmpr_len uint64;
		var  efh_id uint16;
		var efh_datasize uint16;
		var salt=make([]byte,16);
		var bname string;
		//var  d int;
		var magic_enum = 0;  // reserved at 0 for now, we are not computing this (yet).
		//var i uint64;
		var  salt_length uint32;
		var  ef_remaining  uint32= uint32(p.extrafield_length);

		fInfo,err:=fp.Stat()
		if(err!=nil){
			return 0;
		}
		fSize:=fInfo.Size();
		// There could be multiple extra fields, so need to process them all.
		for ( ef_remaining > 0) {
			efh_id = fget16LE(fp);
			efh_datasize = fget16LE(fp);

			// Adjust the bytes processed for id, size and acutal data so the
			// file pointer is moved on correctly,
			// - 2 bytes for the efh_id
			// - 2 bytes for the efh_datasize
			ef_remaining = ef_remaining - 2 - 2 - uint32(efh_datasize);
			if (efh_id == 0x9901) {
				handle_aes_ef(fp, p, efh_datasize);
			} else if (efh_id == 0x0001) {
				handle_zip64_ef(fp, p, efh_datasize, 1);
			} else {
				fp.Seek(int64(efh_datasize),syscall.FILE_CURRENT)
			}
			_seek,err:=fp.Seek(0,syscall.FILE_CURRENT)
			if(_seek==fSize||err!=nil){
				break;
			}

		}
		if p.aes.found==0 {
			fmt.Fprintf(os.Stderr, "Couldn't find (valid) extra header for type 99 AES entry for %s in %s.\n", p.file_name, zip.fname);
			return 0;
		}

		bname = filepath.Base(zip.fname);


		if (p.aes.vendor_version < 1 || p.aes.vendor_version > 2) {
			fmt.Fprintf(os.Stderr, "! Unknown AES encryption version: %d\n", p.aes.vendor_version);
			return 0;
		}
		if (p.aes.strength < 1 || p.aes.strength > 3) {
			fmt.Fprintf(os.Stderr, "! Unknown AES encryption strength: %u\n", p.aes.strength);
			return 0;
		}


		if (p.cmp_len == 0 && (p.flags & FLAG_LOCAL_SIZE_UNKNOWN)>0) {
			scan_for_data_descriptor(zip, p);
		}
		salt_length = uint32(4 + 4*p.aes.strength); // 128 . 8, 192 . 12, 256 . 16
		_n,err:=fp.Read(salt[:salt_length])
		if len(salt) < int(salt_length) || _n!= int(salt_length) {
			fmt.Fprintf(os.Stderr, "Error, in fread of salt!\n");
			return 0;
		}

		fmt.Printf("%s/%s:$zip2$*0*%x*%x*",
				bname, p.file_name, p.aes.strength,
				magic_enum);

		// Print salt value
		fmt.Printf("%s",hex.EncodeToString(salt));


		fmt.Printf("*");
		// Password verification value
		// since in the format we read/compare this one, we do it char by
		// char, so there is no endianity swapping needed. (validator)

		var endianity=make([]byte,2)
		_,err=fp.Read(endianity)
		if err!=nil {
			return 0;
		}
		fmt.Printf("%s",hex.EncodeToString(endianity));


		if (p.cmp_len <= AES_PASSWORD_VERIFICATION_LENGTH + uint64(salt_length) + AES_AUTHENTICATION_CODE_LENGTH) {
			real_cmpr_len = 0;
			fmt.Fprintf(os.Stderr, "!? compressed length of AES entry too short.\n");
		} else {
			// Password verification value . 2 bytes
			// Salt value . salt_length
			// Authentication code . 10 bytes
			real_cmpr_len = p.cmp_len - AES_PASSWORD_VERIFICATION_LENGTH- uint64(salt_length) - AES_AUTHENTICATION_CODE_LENGTH;
		}
		fmt.Printf("*%d*", real_cmpr_len);

		// Actual encrypted data
		if (real_cmpr_len > MAX_BLOB_INLINE_SIZE) {
			_seek,_:=fp.Seek(0,syscall.FILE_CURRENT)
			fmt.Printf("ZFILE*%s*%d*%lx", zip.fname, p.offset, _seek);
			fp.Seek(int64(real_cmpr_len),syscall.FILE_CURRENT)
		} else {
			var real_cmpr=make([]byte,real_cmpr_len)
			_,err:=fp.Read(real_cmpr)
			if err!=nil {
				return 0;
			}
			fmt.Printf("%s",hex.EncodeToString(real_cmpr));
		}
		fmt.Printf("*");
		// Authentication code
		var authCode=make([]byte,AES_AUTHENTICATION_CODE_LENGTH)
		_,err=fp.Read(authCode)
		if err!=nil {
			return 0;
		}
		fmt.Printf("%s",hex.EncodeToString(authCode));
		fmt.Printf("*$/zip2$:%s:%s:%s\n",
				p.file_name, bname, zip.fname);
		return 1;
	}
	/* Try to detect Strong Encryption, bit 6 is sometimes not set */
	if ((p.flags & FLAG_ENCRYPTED)>0 && ((p.flags & FLAG_STRONG_ENCRYPTION)>0 || p.version == 51 || p.version == 52 || p.version >= 61)) {
		// fseek(fp, filename_length, SEEK_CUR);
		// fseek(fp, extrafield_length, SEEK_CUR);
		// continue;

		var iv=make([]byte,16);
		var Erd=make([]byte,256);
		//var  Size uint32;
		var  Format uint32;
		var  AlgId uint16;
		var  Bitlen uint16;
		//var  Flags uint16;
		var  ErdSize uint16;
		var  Reserved1 uint32;
		var  VSize uint16
		var  IVSize uint16;
		var  bname ="";




		fmt.Fprintf(os.Stderr, "Poking at %s in %s to see if it's indeed strong encryption...\n", p.file_name, zip.fname);
		bname = filepath.Base(zip.fname);
		IVSize = fget16LE(fp);
		if (int(IVSize) > len(iv)) {
			fmt.Fprintf(os.Stderr, "No (IV too long: %d)\n", IVSize);
			return 0;
		}
		_n,err:=fp.Read(iv[:IVSize])
		if (_n != int(IVSize)||err!=nil) {
			fmt.Fprintf(os.Stderr, "No (Error reading IV)\n");
			return 0;
		}
		//Size = fget32LE(fp);
		fget32LE(fp);
		Format = uint32(fget16LE(fp));
		if (Format != 3) {
			fmt.Fprintf(os.Stderr, "No (Format == %d)\n", Format);
			return 0;
		}
		AlgId = fget16LE(fp);
		if (AlgId == 0x660E || AlgId == 0x660F || AlgId ==  0x6610) {
			AlgId = 1;
		} else if (AlgId == 0x6603 || AlgId == 0x6609 || AlgId == 0x6720 || AlgId == 0x6721 || AlgId == 0x6801) {
			fmt.Fprintf(os.Stderr, "AlgId (%x) is currently unsupported, please report this to us!\n", AlgId);
			return 0;
		} else {
			fmt.Fprintf(os.Stderr, "No (Unknown AlgId)\n");
			return 0;
		}
		if IVSize == 0 {
			var  crc uint32= p.crc;
			var decomp_len uint64 = p.decomp_len;
			binary.LittleEndian.PutUint32(iv[:4],crc)
			binary.LittleEndian.PutUint64(iv[4:13],decomp_len)
			IVSize = 12;
		}
		Bitlen = fget16LE(fp);
		//Flags = fget16LE(fp);
		fget16LE(fp);
		ErdSize = fget16LE(fp);
		if int(ErdSize) > len(Erd) {
			fmt.Fprintf(os.Stderr, "No (ErdSize too large: %d)\n", ErdSize);
			return 0;
		}
		_n,err=fp.Read(Erd[:ErdSize])
		if _n != int(ErdSize)||err!=nil {
			fmt.Fprintf(os.Stderr, "! Could not fread Erd from file\n");
			return 0;
		}
		Reserved1 = fget32LE(fp);
		if Reserved1 != 0 {
			fmt.Fprintf(os.Stderr, "Reserved1 is %u (non-zero), please report this bug to us!\n", Reserved1);
			return 0;
		}
		VSize = fget16LE(fp);
		fp.Seek(int64(VSize),syscall.FILE_CURRENT)

		fmt.Printf("%s:$zip3$*%d*%d*%d*%d*", bname, 0, AlgId, Bitlen, 0);
		// getting this right isn't important ;)
		fmt.Printf("%s",hex.EncodeToString(iv))
		fmt.Printf("*");
		fmt.Printf("%s",hex.EncodeToString(Erd))
		fmt.Printf("*0*0*0*%s\n", p.file_name);
		return 1;
	}
	return 0;
}

func  magic_type(filename string)  uint16{
	var Buf = filename;
	var  i int;

	if (use_magic==0) {
		return 0;
	}

	Buf=strings.ToUpper(Buf)
	if (len(ascii_fname)>0 && !strings.EqualFold(Buf, ascii_fname)) {
		return 255;
	}


	cp:=strings.IndexByte(Buf,'.')
	if (cp==0) {
		return 0;
	}
	cp++;
	for i = 1; ; i++{
		if Buf[cp+1:]==MagicTypes[i] {
			return uint16(MagicToEnum[i]);
		}
	}
	return 0;
}

/*
func print_hex(unsigned char *p, uint64_t len) {
	while (len--)
		printf("%02x", *p++);
	printf("*");
}*/

// If archive was created from a non-seekable stream, we need to find CRC and
// sizes AFTER file data which means we're in a hen-and-egg situation since we
// don't know the size... I think the below is enough but there may be edge
// cases where we need to also recognize some other kind of start-of-whatever
// and seek back 16 bytes.
// This would also fail if there is some garbage bytes between the end of the
// current file and the next one, but you can't cover everything I guess.
func scan_for_data_descriptor( zip *zip_file,  p *zip_ptr) {
	var fp = zip.fp;
	saved_pos,_ :=fp.Seek(0,syscall.FILE_CURRENT)
	var crc uint32= 0;
	var cmp_len uint64= 0
	var decomp_len uint64 = 0;

	// All values known? Nothing to do.
	if p.cmp_len>0 && p.decomp_len>0 && p.crc>0 {
		return;
	}
	// Flag not set, and both sizes are 0: accept as valid
	if (p.cmp_len == 0 && p.decomp_len == 0 && (p.flags & FLAG_LOCAL_SIZE_UNKNOWN)==0) {
		return;
	}
	// Likewise, no flag set and at least one field filled: accept
	if ((p.cmp_len>0 || p.decomp_len>0 || p.crc>0) && (p.flags & FLAG_LOCAL_SIZE_UNKNOWN)==0) {
		return;
	}
	fInfo,err:=fp.Stat()
	if(err!=nil){
		return ;
	}
	fSize:=fInfo.Size();

	fmt.Fprintf(os.Stderr, "Scanning for EOD... ");
	for  {
		if (fgetc(fp) != 0x50 || fexpect(fp, 0x4b)==0) {
			continue;
		}
		if (fexpect(fp, 0x07)==1 && fexpect(fp, 0x08)==1) {
			// Best case: Found the optional header
			fmt.Fprintf(os.Stderr, "FOUND Extended local header\n");
			crc = fget32LE(fp);
			if (zip.zip64>0) {
				cmp_len = fget64LE(fp);
				decomp_len = fget64LE(fp);
			} else {
				cmp_len = uint64(fget32LE(fp));
				decomp_len = uint64(fget32LE(fp));
			}
			break;
		}
		if (fexpect(fp, 0x03)==1 && fexpect(fp, 0x04)==1) || (fexpect(fp, 0x01)==1 && fexpect(fp, 0x02)==1) {
			// No optional header, but we found something that looks like the
			// start of another file, or the central directory. Assume that
			// the data we're interested in lies directly before this header.
			if (zip.zip64>0){
				fp.Seek(-24,syscall.FILE_CURRENT)
			}else{
				fp.Seek(-16,syscall.FILE_CURRENT)
			}
			crc = fget32LE(fp);
			if (zip.zip64>0) {
				cmp_len = fget64LE(fp);
				decomp_len = fget64LE(fp);
			} else {
				cmp_len = uint64(fget32LE(fp));
				decomp_len = uint64(fget32LE(fp));
			}
			break;
		}

		_seek,_:=fp.Seek(0,syscall.FILE_CURRENT)
		if(fSize==_seek){
			break;
		}
	}

	_seek,_:=fp.Seek(0,syscall.FILE_CURRENT)
	if(fSize==_seek){
		fmt.Fprintf(os.Stderr, "Nothing found.\n");
	} else {
		_seek,_:=fp.Seek(0,syscall.FILE_CURRENT)
		if cmp_len >uint64(_seek) - p.offset {
			fmt.Fprintf(os.Stderr, "!? Compressed len stored after compessed data (%d) is larger than offset between current and next file (%d)\n", cmp_len, uint64(_seek) - p.offset);
		}
		//fprintf(stderr, "cmp_len: %"PRIu64", decomp_len: %"PRIu64", crc32: %"PRIu32"\n",
		//		cmp_len, decomp_len, crc);
		if (p.cmp_len == 0) {
			p.cmp_len = cmp_len;
		}
		if (p.decomp_len == 0) {
			p.decomp_len = decomp_len;
		}
		if (p.crc == 0) {
			p.crc = crc;
		}
	}
	fp.Seek(saved_pos,syscall.FILE_BEGIN)
}

func load_local_header( zfp *zip_file,  p *zip_ptr) int{
	var fp = zfp.fp;
	var  filename_length uint16;


	_offset,_:=fp.Seek(0,syscall.FILE_CURRENT)

	p.offset = uint64(_offset - 4);
	// Ignore mismatches for these for now and trust local over central, but we warn about crc/size below
	p.version = fget16LE(fp) & 0xff; // Remove OS compatibility byte, don't care
	p.flags = fget16LE(fp);
	p.cmptype = fget16LE(fp);
	p.lastmod_time = fget16LE(fp);
	p.lastmod_date = fget16LE(fp);
	if ((p.flags & FLAG_LOCAL_SIZE_UNKNOWN)==0) {
		var  crc uint32
		var cmp_len uint32
		var decomp_len uint32;
		crc = fget32LE(fp);
		cmp_len = fget32LE(fp);
		decomp_len = fget32LE(fp);
		if p.zip64==0 {
			// If we already got 64bit values from the central directory, don't overwrite them again with 32bit ones
			if (crc == 0 && p.crc != 0) {
				fmt.Fprintf(os.Stderr, "Local CRC field is 0, but central one is %d. Weird.\n", p.crc);
			} else {
				p.crc = crc;
			}
			if (cmp_len == 0 && p.cmp_len != 0) {
				fmt.Fprintf(os.Stderr, "Local cmp_len field is 0, but central one is %d. Weird.\n", p.cmp_len);
			} else {
				p.cmp_len = uint64(cmp_len);
			}
			if (decomp_len == 0 && p.decomp_len != 0) {
				fmt.Fprintf(os.Stderr, "Local decomp_len field is 0, but central one is %d. Weird.\n", p.decomp_len);
			} else {
				p.decomp_len = uint64(decomp_len);
			}
		}
	} else { // Local size unknown, skip according fields
		fp.Seek(12,syscall.FILE_CURRENT)
	}
	filename_length = fget16LE(fp);
	p.extrafield_length = fget16LE(fp);

	if (p.file_name != "") {
		fp.Seek(int64(filename_length),syscall.FILE_CURRENT)
	} else {
		_,p.file_name=xfread(  fp, int(filename_length));
	}
	if only_fname != "" && !strings.EqualFold(only_fname, p.file_name) {
		return 0; // Not interested in this one
	}

	p.magic_type = magic_type(p.file_name);
	p.offex = uint64(30 + filename_length + p.extrafield_length);
	return 1;
}

/**
 * Process file in archive with legacy encryption. File pointer
 * is assumed to be at the start of local extra fields.
 */
func process_legacy( zfp *zip_file,  p *zip_ptr)int {
	var fp = zfp.fp;
	fmt.Fprintf(os.Stderr, "ver %d.%d ", p.version / 10, p.version % 10);
	if ( (p.flags & FLAG_ENCRYPTED)>1 &&
	     (p.version == 10 || p.version == 20 || p.version == 45)) {
		var  extra_len_used uint16= 0;

		for (extra_len_used < p.extrafield_length) {
			var efh_id = fget16LE(fp);
			var  efh_datasize = fget16LE(fp);

			fmt.Fprintf(os.Stderr, "efh %04x ", efh_id);

			if (efh_id == 0x0001) {
				handle_zip64_ef(fp, p, efh_datasize, 1);
				extra_len_used += efh_datasize;
				efh_datasize = 0;
			}
			fp.Seek(int64(efh_datasize),syscall.FILE_CURRENT)

			extra_len_used += 4 + efh_datasize;
		}

		if (p.version < 20) {
			zfp.check_bytes = 2;
		}

		scan_for_data_descriptor(zfp, p);

		var PKZIP="";
		if(zfp.zip64 >0){
			PKZIP="64"
		}
		var Encr="TS_chk,";
		if(zfp.check_bytes ==20){
			Encr="2b chk,"
		}

		fmt.Fprintf(os.Stderr,
		        "%s/%s PKZIP%s Encr: %s cmplen=%d, decmplen=%d, crc=%X type=%d\n",
		        filepath.Base(zfp.fname), p.file_name, PKZIP, Encr, p.cmp_len, p.decomp_len, p.crc, p.cmptype);


		_n,err:=fp.Read(p.hash_data[:p.cmp_len])
		if _n!=int(p.cmp_len)||err!=nil {
			fmt.Fprintf(os.Stderr, "Error, fread could not read the data from the file: %s\n", zfp.fname);
			return 0;
		}

		// Ok, now set checksum bytes.  This will depend upon if from crc, or from timestamp
		p.chksum=fmt.Sprintf( "%02x%02x", (p.crc>>24)&0xFF, (p.crc>>16)&0xFF);
		p.chksum2=fmt.Sprintf( "%02x%02x", p.lastmod_time>>8, p.lastmod_time&0xFF);


		return 1;
	}

	scan_for_data_descriptor(zfp, p);

	fmt.Fprintf(os.Stderr, "%s/%s is not encrypted, or stored with non-handled compression type\n", zfp.fname, p.file_name);
	fp.Seek(int64(p.extrafield_length),syscall.FILE_CURRENT)
	fp.Seek(int64(p.cmp_len),syscall.FILE_CURRENT)
	return 0;
}

func move_entry(src *zip_ptr){
	src.file_name = "";
	src.hash_data = nil;
}

/**
 * Process next file in zip archive. ctx.curzip is assumed to
 * be empty or populated with data from the central directory,
 * and the position in the zip file is at the beginning of the
 * local header of the according file.
 */
func handle_file_entry( ctx *zip_context){
	if (load_local_header(&ctx.archive, &ctx.curzip)==0) {
		fmt.Fprintf(os.Stderr, "Skipping bad entry\n");
		return;
	}
	if (ctx.curzip.cmptype == 99) {
		// AES
		if (process_aes(&ctx.archive, &ctx.curzip)!=0) {
			return;
		}
		fmt.Fprintf(os.Stderr, "Skipping bad AES entry\n");
		return;
	}

	// Legacy
	if (process_legacy(&ctx.archive, &ctx.curzip)==0) {
		return;
	}

	if (ctx.curzip.decomp_len < 4) {
		fmt.Fprintf(os.Stderr, "Skipping short file %s\n", ctx.curzip.file_name);
		return;
	}

	// Suitable file with legacy encryption
	var  i=0
	var j=0;

	for i = 0; i < ctx.num_candidates; i++ {
		if (ctx.curzip.cmp_len < ctx.best_files[i].cmp_len) {
			for j = ctx.num_candidates; j > i; j--{
				if (j < MAX_PKZ_FILES) {
					move_entry(&(ctx.best_files[j-1]));
				}
			}
			break;
		}
	}
	move_entry( &ctx.curzip);
	if (ctx.num_candidates < MAX_PKZ_FILES) {
		ctx.num_candidates++;
	}
}

//static void print_and_cleanup(zip_context *ctx);

func init_zip_context( ctx *zip_context, fname string, fp *os.File){
	ctx.archive.fname = fname;
	ctx.archive.check_bytes = 1;
	ctx.archive.fp = fp;
}

/**
 * Forward scan file for local file header signatures and try to
 * process each of these entries. Might yield false positives, or
 * have minor trouble with entries that don't have the size field
 * of the header filled out (see handle_file_entry for details).
 */
func scan_from_start(fname string){
	var fp *os.File;
	var  ctx zip_context;
	var err error
	fp,err=os.Open(fname)
	if (err!=nil) {
		fmt.Fprintf(os.Stderr, "! %s : %s\n", fname, err.Error());
		return;
	}
	init_zip_context(&ctx, fname, fp);
	fInfo,err:=fp.Stat()
	if(err!=nil){
		return ;
	}
	fSize:=fInfo.Size();
	for  {
		if (fgetc(fp) != 0x50 || fexpect(fp, 0x4b)==0) {
			continue;
		}

		if (fexpect(fp, 0x03)==1 && fexpect(fp, 0x04)==1) { /* local header */
			handle_file_entry(&ctx);
	 		// Maybe not worth it - best case we skip over uninteresting parts, but might bail out too early on a false positive
		} else if (fexpect(fp, 0x07) >0&& fexpect(fp, 0x08)>0) { /* data descriptor */
			fp.Seek(12,syscall.FILE_CURRENT)
		} else if ((fexpect(fp, 0x01)>0 && fexpect(fp, 0x02)>0) || (fexpect(fp, 0x05) >0&& fexpect(fp, 0x06)>0)) { /* central directory structures */
			break;
		}
		_seek,err:=fp.Seek(0,syscall.FILE_CURRENT)
		if(err!=nil||_seek==fSize){
			break;
		}
	}

	// This will only print stuff if we found at least one old type encrypted file
	print_and_cleanup(&ctx);
}

func print_and_cleanup( ctx *zip_context){
	var  i int= 1;
	var  bname string;
	var   once int;
	var filenames string;
	if (ctx.num_candidates == 0) {
		return;
	}

	filenames = ctx.best_files[0].file_name;
	bname = filepath.Base(ctx.archive.fname);

	var x1="";
	if(ctx.num_candidates == 1 ){
		x1="/"
	}
	var x2="";
	if(ctx.num_candidates == 1 ){
		x2=ctx.best_files[0].file_name
	}
	fmt.Printf("%s%s%s:$pkzip2$%x*%x*", bname, x1, x2, ctx.num_candidates, ctx.archive.check_bytes);
	if checksum_only>0 {
		i = 0;
	}
	for i=i; i < ctx.num_candidates; i++ {
		var  _len uint64 = 12+24;

		if (i>0) {
			filenames=fmt.Sprintf( "%s, ",filenames);
			filenames=fmt.Sprintf( "%s",ctx.best_files[i].file_name);
		}
		if (ctx.best_files[i].magic_type>0) {
			_len = 12 + 180;
		}
		if (_len > ctx.best_files[i].cmp_len) {
			_len = ctx.best_files[i].cmp_len; // even though we 'could' output a '2', we do not.  We only need one full inflate CRC check file.
		}
		fmt.Printf("1*%x*%x*%d*%s*%s*", ctx.best_files[i].magic_type, ctx.best_files[i].cmptype, _len, ctx.best_files[i].chksum, ctx.best_files[i].chksum2);
		fmt.Printf("%s",hex.EncodeToString(ctx.best_files[i].hash_data));
	}
	// Ok, now output the 'little' one (the first).
	if checksum_only==0 {
		fmt.Printf("%x*%x*%d*%d*%x*%d*%d*%x*", 2, ctx.best_files[0].magic_type, ctx.best_files[0].cmp_len, ctx.best_files[0].decomp_len, ctx.best_files[0].crc, ctx.best_files[0].offset, ctx.best_files[0].offex, ctx.best_files[0].cmptype);
		fmt.Printf("%d*%s*%s*", ctx.best_files[0].cmp_len, ctx.best_files[0].chksum, ctx.best_files[0].chksum2);
		fmt.Printf("%s",hex.EncodeToString(ctx.best_files[0].hash_data));

	}
	/* Don't allow our delimiter in there! */
	filenames=strings.Replace(filenames, ":", " ", 0)
	if ctx.num_candidates > 1 {
		fmt.Printf("$/pkzip2$::%s:%s:%s\n", bname, filenames, ctx.archive.fname);
	} else {
		fmt.Printf("$/pkzip2$:%s:%s::%s\n", filenames, bname, ctx.archive.fname);
	}

	once++;
	if (ctx.num_candidates > 1 && once==0){
		fmt.Fprintf(os.Stderr,
			"NOTE: It is assumed that all files in each archive have the same password.\n",
		"If that is not the case, the hash may be uncrackable. To avoid this, use\n",
		"option -o to pick a file at a time.\n");
	}
}

/**
 * Open given file and scan for the central directory. From there,
 * process every file in the archive that has a central directory
 * entry.
 */
func scan_central_index( fname string){
	var  fp *os.File;
	var  filesize int64;
	var this_disk uint32
	var cd_start_disk uint32;
	var  num_records uint64
	var num_records_total uint64;
	//var cd_size uint64
	var cd_start_offset uint64;
	var ctx zip_context;
	var err error;

	fp,err=os.Open(fname)
	if err!=nil {
		fmt.Fprintf(os.Stderr, "! %s : %s\n", fname, err.Error());
		return;
	}

	fp.Seek(0,syscall.FILE_END)
	filesize,err =fp.Seek(0,syscall.FILE_CURRENT)
	if filesize == -1 ||err!=nil {
		//perror("ftell (trying to get filesize)");
		return
	}
	// First, scan for end of central directory. Its length is 22+n bytes, where n can be up to 64k
	if (filesize > 22 + 65535) {
		fp.Seek(-(22 + 65535),syscall.FILE_END)
	} else {
		fp.Seek(0,syscall.FILE_BEGIN)
	}
	for  {
		if (fgetc(fp) == 0x50 && fexpect(fp, 0x4b)==1) {
			var found int64= 0;
			var  zip64 int= 0;
			if (fexpect(fp, 0x05)==1 && fexpect(fp, 0x06)==1) {
				// Old EOCD header
				found,_=fp.Seek(0,syscall.FILE_CURRENT) ;
				this_disk = uint32(fget16LE(fp));
				cd_start_disk = uint32(fget16LE(fp));
			} else if (fexpect(fp, 0x06)==1 && fexpect(fp, 0x06)==1) {
				// ZIP64 EOCD
				found,_=fp.Seek(0,syscall.FILE_CURRENT)
				zip64 = 1;
				 fget64LE(fp); // size of this record
				 fget16LE(fp); // version made by
				 fget16LE(fp); // needed to extract
				this_disk = fget32LE(fp);
				cd_start_disk = fget32LE(fp);
			}
			if (found>0) {
				if (this_disk != 0 || cd_start_disk != 0) {
					fmt.Fprintf(os.Stderr, "Found EOCD header, but this is either a multipart archive (which are not supported), or false positive. Will keep scanning...\n");
					fp.Seek(found,syscall.FILE_BEGIN)
				} else {
					ctx.archive.zip64 = zip64;
					break;
				}
			}
		}
		_seek,err:=fp.Seek(0,syscall.FILE_CURRENT)
		if(filesize==_seek){
			break;
		}
		if (err!=nil) {
			//perror("fgetc");
			return
		}
	}
	_seek,err:=fp.Seek(0,syscall.FILE_CURRENT)
	if(filesize==_seek){
		fmt.Fprintf(os.Stderr, "Did not find End Of Central Directory.\n");
		return ;
	}
	// Read some info about CD
	if (ctx.archive.zip64>0) {
		num_records = fget64LE(fp);
		num_records_total = fget64LE(fp);
		//cd_size = fget64LE(fp);
		fget64LE(fp);
		cd_start_offset = fget64LE(fp);
		// Followed by: zip64 extensible data sector
	} else {
		num_records = uint64(fget16LE(fp));
		num_records_total = uint64(fget16LE(fp));
		//cd_size = uint64(fget32LE(fp));
			fget32LE(fp);
		cd_start_offset = uint64(fget32LE(fp));
		// Followed by: 2 byte comment length, n bytes comment...
	}

	if (num_records != num_records_total) {
		fmt.Fprintf(os.Stderr, "!? num_records(%d) != num_records_total(%d) for single-file archive. Continuing anyways...\n", num_records, num_records_total);
	}

	// Go back to start of CD and process files from there
	fp.Seek(int64(cd_start_offset),syscall.FILE_BEGIN)

	if (fget32LE(fp) != 0x02014b50) {
		fmt.Fprintf(os.Stderr, "Did not find a Central Directory File Header at expected file offset %d\n", cd_start_offset);
		return ;
	}
	init_zip_context(&ctx, fname, fp);
	for (num_records > 0) {
		var id uint32;
		var  fn_len uint16
		var extra_len uint16
		var comment_len uint16;
		var  old_pos int64;
		num_records--;
		fget16LE(fp); // version made by
		// Upper byte tells OS compatibility, not actual version, mask it
		ctx.curzip.version = fget16LE(fp) & 0xff; // version needed
		ctx.curzip.flags = fget16LE(fp);
		ctx.curzip.cmptype = fget16LE(fp);
		fget16LE(fp); // filemtime
		fget16LE(fp); // filemdate
		ctx.curzip.crc = fget32LE(fp);
		ctx.curzip.cmp_len = uint64(fget32LE(fp));
		ctx.curzip.decomp_len = uint64(fget32LE(fp)); // uncompressed_size
		fn_len = fget16LE(fp);                        // fname_len
		extra_len = fget16LE(fp);                     // extrafield_len
		comment_len = fget16LE(fp);                   // comment_length
		fget16LE(fp);                                 // disk number where file starts
		fget16LE(fp);                                 // internal file attributes
		fget32LE(fp);                                 // external file attributes
		ctx.curzip.offset = uint64(fget32LE(fp));     // relative offset of local file header
		_,ctx.curzip.file_name=xfread( fp, int(fn_len));

		// Handle extra fields
		for (extra_len >= 4) {
			var efh_id = fget16LE(fp);
			var  efh_len = fget16LE(fp);
			extra_len -= 4;
			if (efh_id == 0x0001) {
				// ZIP64
				handle_zip64_ef(fp, &ctx.curzip, efh_len, 0);
			} else if (efh_id == 0x9901) {
				handle_aes_ef(fp, &ctx.curzip, efh_len);
			} else {
				fp.Seek(int64(efh_len),syscall.FILE_CURRENT)
			}
			extra_len -= efh_len;
		}
		old_pos,_=fp.Seek(0,syscall.FILE_CURRENT)
		fp.Seek(int64(ctx.curzip.offset),syscall.FILE_BEGIN)
		id = fget32LE(fp);
		if (id != 0x04034b50) {
			fmt.Fprintf(os.Stderr, "! Did not find local file header for %s at %d\n", ctx.curzip.file_name, ctx.curzip.offset);
		} else {
			handle_file_entry(&ctx);
		}
		fp.Seek(int64( old_pos + int64(extra_len) + int64(comment_len)),syscall.FILE_BEGIN)
		if (num_records > 0) {
			if (fget32LE(fp) != 0x02014b50) {
				fmt.Fprintf(os.Stderr, "No more Central Directory File Headers, but expected %d more.\n", num_records);
				return;
			}
		}
	}
	print_and_cleanup(&ctx);

}


/*
int zip2john(int argc, char **argv)
{
	int c;
	int do_scan = 0;

	/* Parse command line *//*
	while ((c = getopt(argc, argv, "a:o:cm2s")) != -1) {
		switch (c) {
		case 'a':
			ascii_fname = optarg;
			fprintf(stderr, "Using file %s as an 'ASCII' quick check file\n", ascii_fname);
			break;
		case 'o':
			only_fname = optarg;
			fprintf(stderr, "Using file %s as only file to check\n", only_fname);
			break;
		case 'c':
			checksum_only = 1;
			fprintf(stderr, "Outputing hashes that are 'checksum ONLY' hashes\n");
			break;
		case 'm':
			use_magic = 1;
			fprintf(stderr, "Using file 'magic' signatures if applicable (not 100%% safe)\n");
			break;
		case 's':
			do_scan = 1;
			fprintf(stderr, "Scanning archive for local file headers\n");
			break;
		case '?':
		default:
			return usage(argv[0]);
		}
	}
	argc -= optind;
	if (argc == 0)
		return usage(argv[0]);
	argv += optind;

	while(argc--) {
		if (do_scan) {
			scan_from_start(*argv++);
		} else {
			scan_central_index(*argv++);
		}
	}

	cleanup_tiny_memory();

	return EXIT_SUCCESS;
}*/